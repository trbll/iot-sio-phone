<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Viewer</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="viewer-page">
    <main>
      <div id="viewer-app">
        <div id="viewer-canvas-wrap"></div>
        <section id="viewer-overlay">
          <h1>Viewer</h1>
          <p class="muted">
            Listening for IMU updates and applying rotation to the hawk model.
          </p>
          <div class="actions">
            <a class="button secondary" href="/">Back</a>
          </div>
          <div id="status" class="stats">status: waiting for data</div>
        </section>
      </div>
    </main>

    <script src="/socket.io/socket.io.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { STLLoader } from "three/addons/loaders/STLLoader.js";

      // This viewer socket receives relayed IMU data from the server.
      const socket = io();
      const statusEl = document.getElementById("status");
      const wrap = document.getElementById("viewer-canvas-wrap");

      // Basic Three.js scene setup.
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1020);

      const camera = new THREE.PerspectiveCamera(
        60,
        wrap.clientWidth / wrap.clientHeight,
        0.1,
        100
      );
      camera.position.set(0, 1, 4);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      wrap.appendChild(renderer.domElement);

      // OrbitControls lets desktop viewers inspect the model with mouse/trackpad.
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0, 0, 0);
      controls.update();

      const stlLoader = new STLLoader();
      let model = null;
      // Cache the newest IMU sample so early messages are applied after model load.
      let latestRotation = { x: 0, y: 0, z: 0 };

      stlLoader.load(
        "/hawk.stl",
        (geometry) => {
          // Normalize the STL into a predictable size and origin.
          geometry.computeBoundingBox();
          geometry.computeVertexNormals();
          geometry.center();

          const size = new THREE.Vector3();
          geometry.boundingBox.getSize(size);
          const maxDimension = Math.max(size.x, size.y, size.z) || 1;
          const targetSize = 2;
          const scale = targetSize / maxDimension;

          // Requested look: yellow wireframe.
          model = new THREE.Mesh(
            geometry,
            new THREE.MeshStandardMaterial({
              color: 0xffcd00,
              wireframe: true,
              roughness: 0.4,
              metalness: 0.1
            })
          );
          model.scale.setScalar(scale);
          // Apply latest known IMU state at the moment the model appears.
          model.rotation.set(latestRotation.x, latestRotation.y, latestRotation.z);
          scene.add(model);
          setStatus("status: model loaded, waiting for data");
        },
        undefined,
        (error) => {
          console.error(error);
          setStatus("status: failed to load /hawk.stl");
        }
      );

      // Simple lighting rig so wireframe lines are visible against dark background.
      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);

      const directional = new THREE.DirectionalLight(0xffffff, 1.1);
      directional.position.set(3, 4, 5);
      scene.add(directional);

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(12, 12),
        new THREE.MeshStandardMaterial({ color: 0x1d2939, roughness: 1.0, metalness: 0.0 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -1.2;
      scene.add(floor);

      // Incoming payloads are already radians {x,y,z} from the controller.
      socket.on("imu:update", (payload) => {
        if (!payload || !isFinite(payload.x) || !isFinite(payload.y) || !isFinite(payload.z)) {
          return;
        }

        latestRotation = payload;

        if (model) {
          model.rotation.x = payload.x;
          model.rotation.y = payload.y;
          model.rotation.z = payload.z;
        }

        setStatus(
          [
            "status: receiving data",
            `x: ${payload.x.toFixed(3)}`,
            `y: ${payload.y.toFixed(3)}`,
            `z: ${payload.z.toFixed(3)}`,
          ].join("\n")
        );
      });

      socket.on("connect", () => {
        setStatus("status: connected, waiting for data");
      });

      socket.on("disconnect", () => {
        setStatus("status: disconnected");
      });

      window.addEventListener("resize", onResize);
      onResize();
      animate();

      function animate() {
        requestAnimationFrame(animate);
        // Needed each frame when damping is enabled.
        controls.update();
        renderer.render(scene, camera);
      }

      function onResize() {
        // Keep perspective and render buffer aligned with actual canvas size.
        const width = wrap.clientWidth;
        const height = wrap.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }
    </script>
  </body>
</html>
